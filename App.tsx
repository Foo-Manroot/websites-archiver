import React, { useEffect, useState, useRef } from "react";
import { Appearance, SafeAreaView, View, TextInput, Button, Text } from "react-native";
import { WebView } from "react-native-webview";
import RNFS from "react-native-fs";
import Toast, {ErrorToast, InfoToast, SuccessToast} from "react-native-toast-message";
import TurndownService from "turndown";

const App = () => {
  const [url, setUrl] = useState("");
  const [urlReady, setUrlReady] = useState(false);
  const [urlToLoad, setUrlToLoad] = useState<string | null>(null); // State for URL that will be loaded
  const webViewRef = useRef<any>(null);
  const [html2canvas, setHtml2canvas] = useState("");
  const [readability, setReadability] = useState("");
  const [turndown, setTurndown] = useState("");
  const colorScheme = Appearance.getColorScheme();
  // Directory where the generated files will be stored. No subdirectories are created
  const BASE_PATH = `${RNFS.ExternalStorageDirectoryPath}/Documents/archived_websites`;

  const showToast = (title: string, msg: string, type: string = success) => {
    Toast.show({
      type: type,           // Type of toast: "success", "error", "info", etc.
      position: "bottom",        // Position: "top", "bottom", or "center"
      text1: title,
      text2: msg
    });
  };

  /**
   * Async read the external resources
   */
  useEffect (() => {
     // Read the JavaScript files from the assets directory
     const loadScript = async () => {
      /* readFileAssets is ANDROID ONLY !!! */
      RNFS.readFileAssets ("html2canvas.min.js").then (setHtml2canvas).catch (console.error);
      RNFS.readFileAssets ("Readability.js").then (setReadability).catch (console.error);
      RNFS.readFileAssets ("turndown.js").then (setTurndown).catch (console.error);
    }

    loadScript(); // Load the script when the component mounts
  }, []);

  const handleUrlChange = (text: string) => {
    setUrl(text);
  };

  const handleLoadWebsite = () => {
    
    if ( ! url ) {
      showToast ("ERROR", "No URL provided", "error");
    } else {
      showToast ("Loading URL:", url, "info");
      setUrlToLoad(url); // Set the URL to load when the button is clicked
      setUrlReady (false); // So that any export attempts are blocked
    }

  };

  const injectMarkdownConverter = async () => {
    if (webViewRef.current) {
      // Inject dependencies
      webViewRef.current.injectJavaScript (readability);
      webViewRef.current.injectJavaScript (turndown);

      // Create markdown export
      // Thanks to the invaluable work of the markdownload contributors:
      // https://github.com/deathau/markdownload/blob/main/src/background/background.js
      webViewRef.current.injectJavaScript (`
        (async function() {

          // Clone the whole document to keep the original copy clean
          const dom = document.cloneNode (true);

          // Remove duplicated source code generated by code highlighting with enlighter
          // (see https://github.com/EnlighterJS/EnlighterJS/issues/45 , for example )
          dom.body.querySelectorAll('[class*=enlighter-]')?.forEach(elem => {
            elem.outerHTML = elem.className.includes ("enlighter-origin") ? elem.outerHTML : "";
            elem
          });

          dom.body.querySelectorAll('h1, h2, h3, h4, h5, h6')?.forEach(header => {
            // Readability.js will strip out headings from the dom if certain words appear in their className
            // See: https://github.com/mozilla/readability/issues/807  
            header.className = '';
            header.outerHTML = header.outerHTML;
          });

          // Prevent Readability from removing the <html> element if has a 'class' attribute
          // which matches removal criteria.
          dom.documentElement.removeAttribute('class');

          /*************************/
          /** Step 1: Readability **/

          // simplify the dom into an article
          const article = new Readability(dom).parse();


          // and the keywords, should they exist, as an array
          article.keywords = dom.head.querySelector('meta[name="keywords"]')?.content?.split(',')?.map(s => s.trim());
        
          // add all meta tags, so users can do whatever they want
          dom.head.querySelectorAll('meta[name][content], meta[property][content]')?.forEach(meta => {
              const key = (meta.getAttribute('name') || meta.getAttribute('property'))
              const val = meta.getAttribute('content')
              if (key && val && !article[key]) {
                article[key] = val;
              }
            })
          
          var frontmatter = "---\\n";
          
          frontmatter += article.publishedTime? "created: " + article.publishedTime  + "\\n"  : "created: " + new Date ().toISOString () + "\\n";
          frontmatter += article.keywords?      "tags: [" + article.keywords + "]\\n"         : "tags: []\\n" ;
          frontmatter +=                        "source: " + document.baseURI + "\\n";
          frontmatter += article.byline?        "author: " + article.byline + " \\n"          : "";
          frontmatter +=                        "---\\n\\n# " + document.title;
          frontmatter += article.excerpt?       "\\n\\n> ## Excerpt\\n> " + article.excerpt   : "";
          frontmatter += "\\n\\n---\\n";

          /**********************/
          /** Step 2: Turndown **/

          const options = {
            headingStyle: "atx",
            hr: "___",
            bulletListMarker: "-",
            codeBlockStyle: "fenced",
            emDelimiter: "*",
            strongDelimiter: "**",
            linkStyle: "inlined",
            linkReferenceStyle: "full",
          }

          var turndownService = new TurndownService (options);

          function repeat(character, count) {
            return Array(count + 1).join(character);
          }

          function convertToFencedCodeBlock(node, options) {
            node.innerHTML = node.innerHTML.replaceAll('<br-keep></br-keep>', '<br>');
            const langMatch = node.id?.match(/code-lang-(.+)/);
            const language = langMatch?.length > 0 ? langMatch[1] : '';

            const code = node.innerText;

            const fenceChar = options.fence.charAt(0);
            let fenceSize = 3;
            const fenceInCodeRegex = new RegExp('^' + fenceChar + '{3,}', 'gm');

            let match;
            while ((match = fenceInCodeRegex.exec(code))) {
              if (match[0].length >= fenceSize) {
                fenceSize = match[0].length + 1;
              }
            }

            const fence = repeat(fenceChar, fenceSize);

            return (
              '\\n\\n' + fence + language + '\\n' +
              code.replace(/\\n$/, '') +
              '\\n' + fence + '\\n\\n'
            )
          }

          turndownService.addRule('fencedCodeBlock', {
            filter: function (node, options) {
              return (
                options.codeBlockStyle === 'fenced' &&
                node.nodeName === 'PRE' &&
                node.firstChild &&
                node.firstChild.nodeName === 'CODE'
              );
            },
            replacement: function (content, node, options) {
              return convertToFencedCodeBlock(node.firstChild, options);
            }
          });

          // handle <pre> as code blocks
          turndownService.addRule('pre', {
            filter: (node, tdopts) => {
              return node.nodeName == 'PRE'
                     && (!node.firstChild || node.firstChild.nodeName != 'CODE')
                     && !node.querySelector('img');
            },
            replacement: (content, node, tdopts) => {
              return convertToFencedCodeBlock(node, tdopts);
            }
          });


          turndownService.keep (['iframe', 'sub', 'sup', 'u', 'ins', 'del', 'small', 'big']);
          let markdown = frontmatter + turndownService.turndown (article.content);

          let b64 = btoa (unescape (encodeURIComponent (markdown)));

          window.ReactNativeWebView.postMessage (
              JSON.stringify ({
              message_type: "markdown",
              title: document.title,
              page: 1,
              total_pages: 1,
              data: b64
            })
          );

        })();
      `);
    }
  };


  const injectHtml2canvas = async () => {
    if (webViewRef.current) {
      // Inject dependencies
      webViewRef.current.injectJavaScript (html2canvas);

      // Create PNG export
      webViewRef.current.injectJavaScript (`
        (async function() {
          // Remove the headers, which usually contain the breadcrumbs, logos, etc.
          document.body.querySelectorAll ("header")?.forEach (h => { h.outerHTML = "" });

          // Max height to export. Further than this, html2canvas fails
          const maxHeight = 5000;
          const docHeight = document.body.scrollHeight;

          try {
            // Number of images that will be generated
            let parts = Math.ceil (docHeight / maxHeight);
            let start = 0;
            let opts = { scrollY: 0, scrollX: 0, height: maxHeight };
            let b64 = "";
            let canvas = null;

            window.ReactNativeWebView.postMessage (
                JSON.stringify ({
                  message_type: "toast",
                  title: "Image generation",
                  page: 0,
                  total_pages: parts,
                  data: "Will generate " + parts + " screenshots"
                })
              );

            for (currPart = 0; currPart < parts; currPart++) {

              // With this approach, the splits happen anywhere
              // Good if we're merging the images later; not so if
              // we're trying to manually go through them...
              start = currPart * maxHeight;

              // Avoid adding a bunch of empty space after the page ends
              if ( (opts.scrollY + opts.height) > docHeight) {
                opts.height = docHeight - opts.scrollY;
              }
 
              canvas = await html2canvas (document.body, opts);

              // The URL starts with "data:image/png;base64,"
              b64 = canvas.toDataURL ().replace (/^data:[^,]+,/, "");

              window.ReactNativeWebView.postMessage (
                JSON.stringify ({
                  message_type: "raw_img",
                  title: document.title,
                  page: currPart + 1,
                  total_pages: parts,
                  data: b64
                })
              );


              // Negative scroll means scrolling down, apparently
              opts.scrollY -= maxHeight;
            }


          } catch (err) {
            alert (err);
          }

        })();
      `);
    }
  };

  const handleExportScreenshot = () => {

    if ( ! urlReady ) {
      showToast ("ERROR", "Please, first load the URL and let it finish", "error");
      return;
    }

    showToast ("Started conversion to PNG", "Depending on the size of the webpage, this may take a while...", "info");

    // This will send the result as a postMessage, to be handled by handleOnMessage()
    injectHtml2canvas ();
  };

  const handleExportMarkdown = () => {
     if ( ! urlReady ) {
      showToast ("ERROR", "Please, first load the URL and let it finish", "error");
      return;
    }

    showToast ("Started conversion to markdown", "Wait a sec...", "info");

    // This will send the result as a postMessage, to be handled by handleOnMessage()
    injectMarkdownConverter ();
  };

  const handleOnload = (e) => {

    let isLoading = e.nativeEvent.loading;

    if (isLoading) {
      // The webview is still loading
      return;
    }

    showToast ("Page loaded", "You can export it now", "success");
    setUrlReady (true);
  };

  /***************************************/
  /***************************************/

  /**
   * function to turn the title into a valid file name
   * Copied almost verbatim from markdownload:
   *  https://github.com/deathau/markdownload/blob/7e8cc1a2156a5b413db133677641c3f8a23cd39d/src/background/background.js#L347
   */
  const generateValidFileName = (title: string) => {
    // remove < > : " / \ | ? * 
    var illegalRe = /[\/\?<>\\:\*\|":]/g; 
    // and non-breaking spaces (thanks @Licat)
    var name = title.replace(illegalRe, "").replace(new RegExp("\u00A0", "g"), " ")
        // collapse extra whitespace
        .replace(new RegExp(/\s+/, "g"), " ")
        // remove leading/trailing whitespace that can cause issues when using {pageTitle} in a download path
        .trim();
   
    return name;
  }

  /**
   * Saves the file under the Documents directory with the given filename.
   * The data is expected to be a base64-encoded string
   */
  const saveFile = async (filename: string, data_b64: string, parentDir: string = "") => {

    try {
      const filePath = `${BASE_PATH}/${filename}`;

      await RNFS.writeFile (filePath, data_b64, "base64");

 //     showToast ("File saved as:", filename, "success");

    } catch (error) {

      showToast ("Error writing to file", `${error}`, "error");
      console.log (error);
    }
  };

  /**
   * Handler for the messages sent from the webview. The expected format is
   * {
   *    "message_type": <"raw_img"|"markdown"|"toast">,
   *    "page": <int>,
   *    "total_pages": <int>,
   *    "title": "<document.title>",          // Used to generate the filename
   *    "data": "<base64-encoded data>"       // Raw B64, without the data:... prefix
   * }
   */
  const handleOnMessage = (event) => {

    if (! ("nativeEvent" in event)) {
      return;
    }

    let msg = JSON.parse (event.nativeEvent.data);
    let type = msg.message_type;
    let page = msg.page;
    let total = msg.total_pages
    let title = msg.title;

    let timestamp = new Date ().toISOString ().slice (0, 10);
    let filename = timestamp
            + "_"
            + generateValidFileName (title);

    // Only show the pagination if there are multiple pages
    if (total > 1) {
      filename += " (" + page + " of " + total + ")";
    }

    if (type == "markdown") {

      filename += ".md";
      showToast ("Markdown generated", `Saving as ${filename}`, "success");
      saveFile (filename, msg.data);

    } else if (type == "raw_img") {

      filename += ".png";
      showToast ("Image generated", `Page ${page} of ${total}`, "success");
      saveFile (filename, msg.data);

    } else if (type == "toast") {

      showToast (title, msg.data, "info");
    }

  };



  const toastConfig = {
    info:     (props) => ( <InfoToast     {...props} text2NumberOfLines={0} style={{ height: "100%", borderLeftColor: "#87CEFA", borderLeftWidth: 10 }} />),
    success:  (props) => ( <SuccessToast  {...props} text2NumberOfLines={0} style={{ height: "100%", borderLeftColor: "#69C779", borderLeftWidth: 10 }} />),
    error:    (props) => ( <ErrorToast    {...props} text2NumberOfLines={0} style={{ height: "100%", borderLeftColor: "#FE6301", borderLeftWidth: 10 }} />),
  }

  return (
    <SafeAreaView style={{flex: 1, paddingTop: 50, justifyContent: "space-around", gap: "10", paddingHorizontal: 20}}>
      <TextInput
        style={{height: 40, borderColor: "#ccc", borderWidth: 1, color: (colorScheme === "dark")? "white" : "black", marginBottom: 20, paddingHorizontal: 10}}
        placeholder="Enter URL"
        value={url}
        onChangeText={handleUrlChange}
      />
      <Button title="Load Website" onPress={handleLoadWebsite} color="green" />
      <View style={{ flexDirection: "row", width: "100%", display: "flex", justifyContent: "space-around", gap: "10" }}>
        <Button title="Export Markdown" onPress={handleExportMarkdown}        color="orange" />
        <Button title="Export Screenshots" onPress={handleExportScreenshot} color="orange" />
      </View>

      {urlToLoad ? (
         <WebView
          ref={webViewRef}
          source={{ uri: urlToLoad }}
          onMessage={handleOnMessage}
          onLoadEnd={handleOnload}
          injectedJavaScript={`
            // We don't want the mobile version
            let viewport = document.querySelector("meta[name=viewport]");
            viewport.setAttribute ("content", "width=5000");
          `}
          webviewDebuggingEnabled={true}
        />
      ) : (
        <Text style={{marginTop: 20, textAlign: "center", color: "#888"}}>Please enter a URL and press "Load Website"</Text>
      )}

      <Toast
          text1Style={{fontSize: 15}}
          text2Style={{fontSize: 13}}
          config={toastConfig}
      />
    </SafeAreaView>
  );
};

export default App;
